#!/usr/bin/python
#   Developer : Alexey Zakharov (alexey.zakharov@gmail.com)
#   MD5 hash generator from protobuf messages for nanopb types.

import os
import re
import hashlib
import datetime
import argparse

PACKAGE         = "package"
PACKAGE_LEN     = len(PACKAGE)
MESSAGE         = "message"
MESSAGE_LEN     = len(MESSAGE)
SEMICOLON       = ';'
EXTEND          = "extend"
EXTEND_LEN      = len(EXTEND)

def read_file(path):
    with open(path, 'r',encoding='utf-8') as f:
        return f.read()

def findPackage(data):
    packageName = ""
    packNameStart = data.find(PACKAGE)
    if packNameStart >= 0:
        packNameStart = packNameStart + PACKAGE_LEN
        packNameEnd = data.find(SEMICOLON)
        packageName = data[packNameStart:packNameEnd]


    return packageName

def findExtensions(data):
    start = 0
    start = data.find(EXTEND, start)
    if start >= 0:
        print("Warning: Found extensions. Extensions are not supported.")

def findMessages(data):
    messages = dict()
    start = 0
    while start >= 0:
        start = data.find(MESSAGE, start)
        if start >= 0:
            bracket = 0     #counting brackets, when is 0, message is closed
            start = start + MESSAGE_LEN
            end = start
            message = ""
            for c in data[start:] :
                if c == '{' :
                    if len(message) == 0:
                        message = data[start:end]   # obtaining message name

                    bracket = bracket + 1
                elif c == '}':
                    bracket = bracket - 1

                    if bracket == 0:
                        break

                end = end + 1

            substr = data[start:end+1].encode('utf-8')
            h = hashlib.md5()
            h.update(substr)
            md = h.hexdigest()

            messages[md] = message
            start = end

    return messages


def hexToStr(hexNum):
    n = 2
    #s = "0x" + ", 0x".join([hexNum[i:i+n] for i in range(0, len(hexNum), n)])
    s = ", ".join([str(int(hexNum[i:i+n],16)) for i in range(0, len(hexNum), n)])

    return s


def generateJson(packageName, messages, filename_output="UNDEFINED", filename_input="UNDEFINED"):
     # generating body

    code = "[\n"

    for key in messages:
        type = messages[key]
        code = code + "    {\n"                                      \
               "        \"type\": \"" + type + "\",\n"               \
               "        \"hash\": [" + hexToStr(key) + "]\n"         \
               "    },\n"


    code = code.rstrip(",\n")
    code = code + "\n]\n"

    return code;

def generateCpp(packageName, messages, filename_output="UNDEFINED", filename_input="UNDEFINED"):

    #generating static header
    code = "/* Automatically generated hashes for nanopb types */\n"                                                             \
           "/* Generated by proto_hashgen from" + filename_input +" at " + datetime.datetime.now().strftime("%c") + ". */\n"     \
           "#ifndef " + filename_output.upper() + "_INCLUDED\n"                                                                  \
           "#define " + filename_output.upper() + "_INCLUDED\n\n"                                                                \
           "template <class T>\n"                                                                                                \
           "inline const unsigned char* get_hash()\n"                                                                            \
           "{\n"                                                                                                                 \
           "    return NULL;\n"                                                                                                  \
           "}\n\n"


    # generating body
    for key in messages:
        type = messages[key]
        code = code + "template <>\n"                                                       \
               "inline const unsigned char* get_hash<" + packageName + "_" + type + ">()\n" \
               "{\n"                                                                        \
               "    static unsigned char type[] = {" + hexToStr(key) + "};\n"               \
               "    return type;\n"                                                         \
                "}\n\n"

    # generating static footer
    code = code + "#endif\n"

    return code


def main():

    parser = argparse.ArgumentParser(prog='proto_hashgen', description='MD5 hash generator for nanopb')
    parser.add_argument("filename", type=str, help=".proto file name")
    parser.add_argument('-o', '--output', help='output file name', required=False, default="")
    parser.add_argument('-v', '--verbose', help='verbose mode', required=False, action='store_const', const=True, default=False)
    parser.add_argument('-c', '--cpp', help='cpp header with hashes', required=False, action='store_const', const=True, default=False)
    parser.add_argument('-j', '--json', help='json file with hashes', required=False, action='store_const', const=True, default=False)

    args = parser.parse_args()
    path_input = args.filename
    filename_input = os.path.basename(path_input)

    path_output = args.output
    filename_output = os.path.basename(path_output)

    if not path_output:
        filename_output = filename_input.replace(".proto", "_hash")
        path_output = filename_output
    else:
        index = filename_output.rfind(".")
        if index > 0:
            filename_output = filename_output[:index]

    messages = dict()
    data = ""

    with open(path_input,'r') as fin:
        data = fin.read()
        data = re.sub(r'/{2,2}.*\n', "", data)
        for ch in [' ','\t', '\n']:
            data = data.replace(ch, "")

    packageName = findPackage(data)
    messageNameDict = findMessages(data)
    findExtensions(data)

    if args.cpp:
        codeCpp = generateCpp(packageName, messageNameDict, filename_output+"_H")
        with open(path_output+".h",'w') as fin:
            fin.write(codeCpp)

    if args.json:
        codeJson = generateJson(packageName, messageNameDict)
        with open(path_output+".json",'w') as fin:
            fin.write(codeJson)


if __name__ == "__main__":
    main()

