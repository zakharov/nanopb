#!/usr/bin/python
#   Developer : Alexey Zakharov (alexey.zakharov@gmail.com)
#   MD5 hash generator from protobuf messages for nanopb types.

import os
import re
import hashlib
import datetime
import argparse

PACKAGE         = "package"
PACKAGE_LEN     = len(PACKAGE)
MESSAGE         = "message"
MESSAGE_LEN     = len(MESSAGE)
SEMICOLON       = ';'
EXTEND          = "extend"
EXTEND_LEN      = len(EXTEND)

def read_file(path):
    with open(path, 'r',encoding='utf-8') as f:
        return f.read()

def findPackage(data):
    packageName = ""
    packNameStart = data.find(PACKAGE)
    if packNameStart >= 0:
        packNameStart = packNameStart + PACKAGE_LEN
        packNameEnd = data.find(SEMICOLON)
        packageName = data[packNameStart:packNameEnd]


    return packageName

def findExtensions(data):
    start = 0
    start = data.find(EXTEND, start)
    if start >= 0:
        print("Warning: Found extensions. Extensions are not supported.")

def findMessages(data):
    messages = dict()
    start = 0
    while start >= 0:
        start = data.find(MESSAGE, start)
        if start >= 0:
            bracket = 0     #counting brackets, when is 0, message is closed
            start = start + MESSAGE_LEN
            end = start
            message = ""
            for c in data[start:] :
                if c == '{' :
                    if len(message) == 0:
                        message = data[start:end]   # obtaining message name

                    bracket = bracket + 1
                elif c == '}':
                    bracket = bracket - 1

                    if bracket == 0:
                        break

                end = end + 1

            substr = data[start:end+1].encode('utf-8')
            h = hashlib.md5()
            h.update(substr)
            md = h.hexdigest()

            messages[md] = message
            start = end

    return messages


def hexToStr(hexNum):
    n=2
    s = "0x" + ", 0x".join([hexNum[i:i+n] for i in range(0, len(hexNum), n)])
    return s

def generate(packageName, messages, filename_output="UNDEFINED", filename_input="UNDEFINED"):

    #generating static header

    code = "/* Automatically generated hashes for nanopb types */\n"                                               		 \
           "/* Generated by proto_hashgen from" + filename_input +" at " + datetime.datetime.now().strftime("%c") + ". */\n"     \
           "#ifndef " + filename_output.upper() + "_INCLUDED\n"                                                                \
           "#define " + filename_output.upper() + "_INCLUDED\n\n"                                                              \
           "template <class T>\n"                                                                                   		 \
           "inline const unsigned char* get_hash()\n"                                                               		 \
           "{\n"                                                                                                    		 \
           "    static unsigned char type[] = {0};\n"                                                               		 \
           "    return type;\n"                                                                                     		 \
           "}\n\n"


    # generating body
    for key in messages:
        type = messages[key]
        code = code + "template <>\n"								\
               "inline const unsigned char* get_hash<" + packageName + "_" + type + ">()\n"	\
               "{\n"                                                                    	\
               "    static unsigned char type[] = {" + hexToStr(key) + "};\n"			\
               "    return type;\n"								\
                "}\n\n"

    # generating static footer
    code = code + "#endif\n"

    return code


def main():

    parser = argparse.ArgumentParser(prog='proto_hashgen', description='MD5 hash generator for nanopb')
    parser.add_argument("filename", type=str, help=".proto file name")
    parser.add_argument('-o', '--output', help='output file name', required=False, default="")
    parser.add_argument('-v', '--verbose', help='verbose mode', required=False, action='store_const', const=True, default=False)

    args = parser.parse_args()
    path_input = args.filename
    filename_input = os.path.basename(path_input)

    path_output = args.output
    ext_output = "h"
    filename_output = os.path.basename(path_output)

    if not path_output:
        filename_output = filename_input.replace(".proto", "_hash")
        path_output = filename_output + "." + ext_output
    else:
        index = filename_output.rfind(".")
        if index > 0:
            ext_output = filename_output[index+1:]
            filename_output = filename_output[:index]

    messages = dict()
    data = ""

    with open(path_input,'r') as fin:
        data = fin.read()
        data = re.sub(r'/{2,2}.*\n', "", data)
        for ch in [' ','\t', '\n']:
            data = data.replace(ch, "")

    packageName = findPackage(data)
    messageNameDict = findMessages(data)
    findExtensions(data)
    code = generate(packageName, messageNameDict, filename_output+"_"+ext_output)

    if args.verbose:
        print(code)

    with open(path_output,'w') as fin:
        fin.write(code)

if __name__ == "__main__":
    main()

